flyfish中每一个kv对都有一个关联的version。当kv对被创建时version=1,之后每次变更version+1。

## version的用途1

对于get命令，如果不携带version参数，flyfish将返回请求的所有数据。

如果携带了version,服务器将检查version与服务器中存储的是否一致，如果一致，将不向客户端返回任何数据。

因此，携带version可以减少不必要的网络流量。

## version的用途2

version可以用于实现乐观锁机制。

对与同一个数据项有多个更改者的情况。考虑如下业务处理逻辑：

1. 服务器接收客户端请求，请求将用户A的Gold+1。
2. 服务器向flyfish加载A的数据，A.Gold+1,将数据回写。

如果有多个服务器可以接受对A的服务请求，在没有分布式锁的场景下将会导致数据覆盖。针对此场景，可以使用flyfish的verison实现乐观锁，避免数据覆盖的出现。使用乐观锁的处理流程如下：

1. 服务器接收客户端请求，请求将用户A的Gold+1。
2. 服务器向flyfish加载A的数据，记录当前version,A.Gold+1,回写请求携带version。
3. flyfish接收到更新请求，如果version一致返回成功，否则通知版本号不一致。
4. 如果服务器发现版本号不一致，返回第2步重新执行。

## 一些示例

### 全局定时事件

在服务器中，每晚8点整将触发一个事件（例如向所有在线用户发放奖励）。对事件触发有以下要求：

1. 除非所有服务器发生故障停机，否则 时间超过8点之后必须要触发
2. 事件只能触发一次（例如有多台服务器触发了事件，多次发放奖励是严重的运营事故）。

可以使用version机制优雅的实现这个需求：

1. 在数据库中记录事件下一次触发时间。
2. 多个进程请求加载下一次触发时间，并记录下版本号。
3. 到达触发时间时，将触发时间设置成下一次触发时间，携带version请求更新到flyfish。
4. 只有一个进程能更新成功，成功的进程负责触发事件。失败进程重新请求加载下一次更新时间。

### 选主

数据库中记录master的id以及失效时间。

进程加载master记录。

如果记录不存在：使用setNx请求将自己设置为master。如果setNx成功当前进程成为master。

如果记录存在：判断是否超过失效时间，如果超过，使用version，将自己设置为master,如果成功当前进程成为master。

对于master:应该在失效时间到达前，更新到期时间，如果更新失败则丢失master。

对于非master:发现当前时间超过失效时间，使用记录下的版本号请求将自己设置为master。如果成功成为master。否则请求加载最新master信息。



























